package com.tangem.commands.common.card

import com.squareup.moshi.JsonClass
import com.tangem.commands.CommandResponse
import com.tangem.commands.SignCommand
import com.tangem.commands.common.card.masks.ProductMask
import com.tangem.commands.common.card.masks.SettingsMask
import com.tangem.commands.common.card.masks.SigningMethodMask
import com.tangem.commands.read.ReadCommand
import com.tangem.commands.wallet.CardWallet
import com.tangem.commands.wallet.WalletIndex
import com.tangem.common.tlv.TlvTag
import java.util.*

/**
 * Response for [ReadCommand]. Contains detailed card information.
 */
@JsonClass(generateAdapter = true)
data class Card(

    /**
     * Unique Tangem card ID number.
     */
    val cardId: String,

    /**
     * Name of Tangem card manufacturer.
     */
    val manufacturerName: String,

    /**
     * Current status of the card.
     */
    val status: CardStatus?,

    /**
     * Version of Tangem COS.
     */
    val firmwareVersion: FirmwareVersion,

    /**
     * Public key that is used to authenticate the card against manufacturer’s database.
     * It is generated one time during card manufacturing.
     */
    val cardPublicKey: ByteArray?,

    internal val defaultCurve: EllipticCurve?,

    /**
     * Card settings defined by personalization (bit mask: 0 – Enabled, 1 – Disabled).
     */
    val settingsMask: SettingsMask?,

    /**
     * Public key that is used by the card issuer to sign IssuerData field.
     */
    val issuerPublicKey: ByteArray?,

    /**
     * Defines what data should be submitted to SIGN command.
     */
    val signingMethods: SigningMethodMask?,

    /**
     * Delay in seconds before COS executes commands protected by PIN2.
     */
    val pauseBeforePin2: Int?,

    /**
     * Maximum number of wallets that can be created for this card
     */
    val walletsCount: Int?,

    /**
     * Index of corresponding wallet
     */
    val walletIndex: Int?,

    /**
     * Any non-zero value indicates that the card experiences some hardware problems.
     * User should withdraw the value to other blockchain wallet as soon as possible.
     * Non-zero Health tag will also appear in responses of all other commands.
     */
    val health: Int?,

    /**
     * Whether the card requires issuer’s confirmation of activation.
     * is "true" if the card requires activation,
     * is 'false" if the card is activated or does not require activation
     */
    val isActivated: Boolean,

    /**
     * A random challenge generated by personalisation that should be signed and returned
     * to COS by the issuer to confirm the card has been activated.
     * This field will not be returned if the card is activated.
     */
    val activationSeed: ByteArray?,

    /**
     * Returned only if [SigningMethod.SignPos] enabling POS transactions is supported by card.
     */
    val paymentFlowVersion: ByteArray?,

    /**
     * This value can be initialized by terminal and will be increased by COS on execution of every [SignCommand].
     * For example, this field can store blockchain “nonce” for quick one-touch transaction on POS terminals.
     * Returned only if [SigningMethod.SignPos]  enabling POS transactions is supported by card.
     */
    val userCounter: Int?,

    /**
     * This value can be initialized by App (with PIN2 confirmation) and will be increased by COS
     * with the execution of each [SignCommand]. For example, this field can store blockchain “nonce”
     * for a quick one-touch transaction on POS terminals. Returned only if [SigningMethod.SignPos].
     */
    val userProtectedCounter: Int?,

    /**
     * When this value is true, it means that the application is linked to the card,
     * and COS will not enforce security delay if [SignCommand] will be called
     * with [TlvTag.TerminalTransactionSignature] parameter containing a correct signature of raw data
     * to be signed made with [TlvTag.TerminalPublicKey].
     */
    val terminalIsLinked: Boolean,

    /**
     * Detailed information about card contents. Format is defined by the card issuer.
     * Cards complaint with Tangem Wallet application should have TLV format.
     */
    val cardData: CardData?,

    val isPin1Default: Boolean? = null,

    val isPin2Default: Boolean? = null,

    val wallets: List<CardWallet>
) : CommandResponse {

    fun setWallets(newWallets: List<CardWallet>): Card {
        val sortedWallets = newWallets.toMutableList().apply { sortBy { it.index } }
        return this.copy(wallets = sortedWallets.toList())
    }

    fun wallet(index: WalletIndex): CardWallet? {
        return when (index) {
            is WalletIndex.Index -> wallets.firstOrNull { it.index == index.index }
            is WalletIndex.PublicKey -> wallets.firstOrNull { it.publicKey?.contentEquals(index.data) == true }
        }
    }

    fun updateWallet(wallet: CardWallet): Card {
        val mutableWallets = wallets.toMutableList()
        val foundIndex = mutableWallets.indexOfFirst { it.index == wallet.index }
        return if (foundIndex != -1) {
            mutableWallets[foundIndex] = wallet
            this.copy(wallets = mutableWallets.toList())
        } else {
            this
        }
    }
}

/**
 * Detailed information about card contents.
 */
@JsonClass(generateAdapter = true)
class CardData(

    /**
     * Tangem internal manufacturing batch ID.
     */
    val batchId: String?,

    /**
     * Timestamp of manufacturing.
     */
    val manufactureDateTime: Date?,

    /**
     * Name of the issuer.
     */
    val issuerName: String?,

    /**
     * Name of the blockchain.
     */
    val blockchainName: String?,

    /**
     * Signature of CardId with manufacturer’s private key.
     */
    val manufacturerSignature: ByteArray?,

    /**
     * Mask of products enabled on card.
     */
    val productMask: ProductMask?,

    /**
     * Name of the token.
     */
    val tokenSymbol: String?,

    /**
     * Smart contract address.
     */
    val tokenContractAddress: String?,

    /**
     * Number of decimals in token value.
     */
    val tokenDecimal: Int?
)

/**
 * Status of the card and its wallet.
 */
enum class CardStatus(val code: Int) {
    NotPersonalized(0),
    Empty(1),
    Loaded(2),
    Purged(3);

    companion object {
        private val values = values()
        fun byCode(code: Int): CardStatus? = values.find { it.code == code }
    }
}