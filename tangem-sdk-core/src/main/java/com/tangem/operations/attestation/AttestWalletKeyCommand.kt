package com.tangem.operations.attestation

import com.squareup.moshi.JsonClass
import com.tangem.common.CompletionResult
import com.tangem.common.apdu.CommandApdu
import com.tangem.common.apdu.Instruction
import com.tangem.common.apdu.ResponseApdu
import com.tangem.common.card.*
import com.tangem.common.core.*
import com.tangem.common.extensions.guard
import com.tangem.common.tlv.TlvBuilder
import com.tangem.common.tlv.TlvDecoder
import com.tangem.common.tlv.TlvTag
import com.tangem.crypto.CryptoUtils
import com.tangem.operations.Command
import com.tangem.operations.CommandResponse

/**
 * Deserialized response from the Tangem card after `AttestWalletKeyCommand`.
 */
@JsonClass(generateAdapter = true)
class AttestWalletKeyResponse(
    /**
     * Unique Tangem card ID number
     */
    val cardId: String,
    /**
     * Random salt generated by the card
     */
    val salt: ByteArray?,
    /**
     * Challenge and salt signed with the wallet private key.
     */
    val walletSignature: ByteArray?,
    /**
     * Challenge, used to check wallet
     */
    val challenge: ByteArray,
    /**
     * Counter of `AttestWalletKey` command executions. A very big value of this counter may indicate a hacking attempts.
     */
    internal val counter: Int?,
) : CommandResponse

/**
 * This command proves that the wallet private key from the card corresponds to the wallet public key.
 * Standard challenge/response scheme is used.
 * @property walletIndex: Index key of the wallet to check
 * @property challenge: Optional challenge. If null, it will be created automatically and returned in command response
 */
class AttestWalletKeyCommand(
    val walletIndex: WalletIndex,
    var challenge: ByteArray? = null,
) : Command<AttestWalletKeyResponse>() {

    override fun performPreCheck(card: Card): TangemSdkError? {
        if (card.wallet(walletIndex) == null) {
            return TangemSdkError.WalletNotFound()
        }

        return null
    }

    override fun run(session: CardSession, callback: CompletionCallback<AttestWalletKeyResponse>) {
        challenge = challenge ?: CryptoUtils.generateRandomBytes(16)

        super.run(session) { result ->
            when (result) {
                is CompletionResult.Success -> {
                    val checkWalletResponse = result.data
                    val wallet = session.environment.card?.wallet(walletIndex).guard {
                        callback(CompletionResult.Failure(TangemSdkError.CardError()))
                        return@run
                    }
                    val verifyResult = verify(checkWalletResponse, wallet)
                    if (verifyResult == true) {
                        callback(CompletionResult.Success(checkWalletResponse))
                    } else {
                        callback(CompletionResult.Failure(TangemSdkError.CardVerificationFailed()))
                    }
                }
                is CompletionResult.Failure -> callback(result)
            }
        }
    }

    override fun serialize(environment: SessionEnvironment): CommandApdu {
        val builder = TlvBuilder()
        builder.append(TlvTag.Pin, environment.accessCode.value)
        builder.append(TlvTag.CardId, environment.card?.cardId)
        builder.append(TlvTag.Challenge, challenge)
        builder.append(TlvTag.WalletIndex, walletIndex)

        return CommandApdu(Instruction.AttestWalletKey, builder.serialize())
    }

    override fun deserialize(
        environment: SessionEnvironment,
        apdu: ResponseApdu
    ): AttestWalletKeyResponse {
        val tlv = apdu.getTlvData(environment.encryptionKey)
            ?: throw TangemSdkError.DeserializeApduFailed()

        val decoder = TlvDecoder(tlv)
        return AttestWalletKeyResponse(
            decoder.decode(TlvTag.CardId),
            decoder.decode(TlvTag.Salt),
            decoder.decode(TlvTag.WalletSignature),
            challenge!!,
            decoder.decode(TlvTag.CheckWalletCounter),
        )
    }

    private fun verify(response: AttestWalletKeyResponse, wallet: CardWallet): Boolean? {
        val signature = response.walletSignature ?: return null
        val salt = response.salt ?: return null

        return CryptoUtils.verify(
            publicKey = wallet.publicKey,
            message = challenge!! + salt,
            signature = signature,
            curve = wallet.curve
        )
    }
}