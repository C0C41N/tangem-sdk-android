package com.tangem.operations.attestation

import com.tangem.common.CompletionResult
import com.tangem.common.apdu.CommandApdu
import com.tangem.common.apdu.Instruction
import com.tangem.common.apdu.ResponseApdu
import com.tangem.common.card.EllipticCurve
import com.tangem.common.core.*
import com.tangem.common.extensions.guard
import com.tangem.common.tlv.TlvBuilder
import com.tangem.common.tlv.TlvDecoder
import com.tangem.common.tlv.TlvTag
import com.tangem.crypto.CryptoUtils
import com.tangem.operations.Command
import com.tangem.operations.CommandResponse
import com.tangem.operations.PreflightReadMode
import com.tangem.operations.read.WalletPointer

/**
 * Deserialized response from the Tangem card after `AttestWalletKeyCommand`.
 */
class AttestWalletKeyResponse(
    /**
     * Unique Tangem card ID number
     */
    val cardId: String,
    /**
     * Random salt generated by the card
     */
    val salt: ByteArray?,
    /**
     * Challenge and salt signed with the wallet private key.
     */
    val walletSignature: ByteArray?,
    /**
     * Challenge, used to check wallet
     */
    val challenge: ByteArray,
    /**
     * Counter of `AttestWalletKey` command executions. A very big value of this counter may indicate a hacking attempts.
     */
    internal val counter: Int?,
) : CommandResponse

/**
 * This command proves that the wallet private key from the card corresponds to the wallet public key.
 * Standard challenge/response scheme is used.
 * @property publicKey: Public key of the wallet to check
 * @property challenge: Optional challenge. If null, it will be created automatically and returned in command response
 */
class AttestWalletKeyCommand(
    val walletPublicKey: ByteArray,
    var challenge: ByteArray? = null,
) : Command<AttestWalletKeyResponse>() {

    override fun preflightReadMode(): PreflightReadMode = PreflightReadMode.ReadWallet(WalletPointer.WalletPublicKey(walletPublicKey))

    override fun run(session: CardSession, callback: CompletionCallback<AttestWalletKeyResponse>) {
        challenge = challenge ?: CryptoUtils.generateRandomBytes(16)

        super.run(session) { result ->
            when (result) {
                is CompletionResult.Success -> {
                    val checkWalletResponse = result.data
                    val curve = session.environment.card?.wallet(walletPublicKey)?.curve.guard {
                        callback(CompletionResult.Failure(TangemSdkError.CardError()))
                        return@run
                    }
                    val verifyResult = verify(checkWalletResponse, curve)
                    if (verifyResult == true) {
                        callback(CompletionResult.Success(checkWalletResponse))
                    } else {
                        callback(CompletionResult.Failure(TangemSdkError.VerificationFailed()))
                    }
                }
                is CompletionResult.Failure -> callback(result)
            }
        }
    }

    override fun serialize(environment: SessionEnvironment): CommandApdu {
        val builder = TlvBuilder()
        builder.append(TlvTag.Pin, environment.accessCode.value)
        builder.append(TlvTag.CardId, environment.card?.cardId)
        builder.append(TlvTag.Challenge, challenge)
        builder.append(TlvTag.WalletPublicKey, walletPublicKey)
        return CommandApdu(Instruction.AttestWalletKey, builder.serialize())
    }

    override fun deserialize(environment: SessionEnvironment, apdu: ResponseApdu): AttestWalletKeyResponse {
        val tlv = apdu.getTlvData(environment.encryptionKey) ?: throw TangemSdkError.DeserializeApduFailed()
        val decoder = TlvDecoder(tlv)
        return AttestWalletKeyResponse(
                decoder.decode(TlvTag.CardId),
                decoder.decode(TlvTag.Salt),
                decoder.decode(TlvTag.WalletSignature),
                challenge!!,
                decoder.decode(TlvTag.CheckWalletCounter),
        )
    }

    private fun verify(response: AttestWalletKeyResponse, curve: EllipticCurve): Boolean? {
        val signature = response.walletSignature ?: return null
        val salt = response.salt ?: return null

        return CryptoUtils.verify(walletPublicKey, challenge!! + salt, signature, curve)
    }
}