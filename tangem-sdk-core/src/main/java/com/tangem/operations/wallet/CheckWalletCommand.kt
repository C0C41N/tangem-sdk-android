package com.tangem.operations.wallet

import com.squareup.moshi.JsonClass
import com.tangem.common.card.EllipticCurve
import com.tangem.crypto.CryptoUtils
import com.tangem.operations.CommandResponse

/**
 * Deserialized response from the Tangem card after [CheckWalletCommand].
 *
 * @property cardId Unique Tangem card ID number
 * @property salt Random salt generated by the card.
 * @property walletSignature Challenge and salt signed with the wallet private key.
 */
@JsonClass(generateAdapter = true)
class CheckWalletResponse(
    val cardId: String,
    val salt: ByteArray,
    val walletSignature: ByteArray
) : CommandResponse {

    fun verify(curve: EllipticCurve, publicKey: ByteArray, challenge: ByteArray): Boolean {
        return CryptoUtils.verify(
                publicKey,
                challenge + salt,
                walletSignature,
                curve)
    }
}

/**
 * This command proves that the wallet private key from the card corresponds to the wallet public key.
 * Standard challenge/response scheme is used.
 * @property walletIndex Pointer to wallet for interaction
 * @property challenge Random challenge generated by application
 */
//class CheckWalletCommand(
//    private val curve: EllipticCurve,
//    private val publicKey: ByteArray,
//) : Command<CheckWalletResponse>() {
//
//    private val walletIndex: WalletIndex = WalletIndex.PublicKey(publicKey)
//
//    private val challenge = CryptoUtils.generateRandomBytes(16)
//
//    override fun run(session: CardSession, callback: CompletionCallback<CheckWalletResponse>) {
//        super.run(session) { result ->
//            when (result) {
//                is CompletionResult.Failure -> {
//                    callback(CompletionResult.Failure(result.error))
//                }
//                is CompletionResult.Success -> {
//                    val verified = result.data.verify(curve, publicKey, challenge)
//                    if (verified) {
//                        callback(CompletionResult.Success(result.data))
//                    } else {
//                        callback(CompletionResult.Failure(TangemSdkError.CardVerificationFailed()))
//                    }
//                }
//            }
//        }
//    }
//
//    override fun performPreCheck(card: Card): TangemSdkError? {
//        if (card.status == Card.Status.NotPersonalized) {
//            return TangemSdkError.NotPersonalized()
//        }
//        if (card.isActivated) {
//            return TangemSdkError.NotActivated()
//        }
//        return null
//    }
//
//    override fun serialize(environment: SessionEnvironment): CommandApdu {
//        val tlvBuilder = TlvBuilder()
//        tlvBuilder.append(TlvTag.Pin, environment.accessCode.value)
//        tlvBuilder.append(TlvTag.CardId, environment.card?.cardId)
//        tlvBuilder.append(TlvTag.Challenge, challenge)
//        walletIndex.addTlvData(tlvBuilder)
//        return CommandApdu(Instruction.AttestWalletKey, tlvBuilder.serialize())
//    }
//
//    override fun deserialize(environment: SessionEnvironment, apdu: ResponseApdu): CheckWalletResponse {
//        val tlvData = apdu.getTlvData(environment.encryptionKey) ?: throw TangemSdkError.DeserializeApduFailed()
//
//        val decoder = TlvDecoder(tlvData)
//        return CheckWalletResponse(
//                cardId = decoder.decode(TlvTag.CardId),
//                salt = decoder.decode(TlvTag.Salt),
//                walletSignature = decoder.decode(TlvTag.WalletSignature)
//        )
//    }
//}