package com.tangem.commands.common.card

import com.tangem.commands.CommandResponse
import com.tangem.commands.ReadCommand
import com.tangem.commands.SignCommand
import com.tangem.commands.common.card.masks.ProductMask
import com.tangem.commands.common.card.masks.SettingsMask
import com.tangem.commands.common.card.masks.SigningMethodMask
import com.tangem.common.tlv.TlvTag
import java.util.*

/**
 * Response for [ReadCommand]. Contains detailed card information.
 */
data class Card(

    /**
     * Unique Tangem card ID number.
     */
    val cardId: String,

    /**
     * Name of Tangem card manufacturer.
     */
    val manufacturerName: String,

    /**
     * Current status of the card.
     */
    val status: CardStatus?,

    /**
     * Version of Tangem COS.
     */
    val firmwareVersion: String?,

    /**
     * Public key that is used to authenticate the card against manufacturer’s database.
     * It is generated one time during card manufacturing.
     */
    val cardPublicKey: ByteArray?,

    /**
     * Card settings defined by personalization (bit mask: 0 – Enabled, 1 – Disabled).
     */
    val settingsMask: SettingsMask?,

    /**
     * Public key that is used by the card issuer to sign IssuerData field.
     */
    val issuerPublicKey: ByteArray?,

    /**
     * Explicit text name of the elliptic curve used for all wallet key operations.
     * Supported curves: ‘secp256k1’ and ‘ed25519’.
     */
    val curve: EllipticCurve?,

    /**
     * Total number of signatures allowed for the wallet when the card was personalized.
     */
    val maxSignatures: Int?,

    /**
     * Defines what data should be submitted to SIGN command.
     */
    val signingMethods: SigningMethodMask?,

    /**
     * Delay in seconds before COS executes commands protected by PIN2.
     */
    val pauseBeforePin2: Int?,

    /**
     * Maximum number of wallets that can be created for this card
     */
    val walletsCount: Int?,

    /**
     * Index of corresponding wallet
     */
    val walletIndex: Int?,

    /**
     * Public key of the blockchain wallet.
     */
    val walletPublicKey: ByteArray?,

    /**
     * Remaining number of [SignCommand] operations before the wallet will stop signing transactions.
     */
    val walletRemainingSignatures: Int?,

    /**
     * Total number of signed single hashes returned by the card in
     * [SignCommand] responses since card personalization.
     * Sums up array elements within all [SignCommand].
     */
    val walletSignedHashes: Int?,

    /**
     * Any non-zero value indicates that the card experiences some hardware problems.
     * User should withdraw the value to other blockchain wallet as soon as possible.
     * Non-zero Health tag will also appear in responses of all other commands.
     */
    val health: Int?,

    /**
     * Whether the card requires issuer’s confirmation of activation.
     * is "true" if the card requires activation,
     * is 'false" if the card is activated or does not require activation
     */
    val isActivated: Boolean,

    /**
     * A random challenge generated by personalisation that should be signed and returned
     * to COS by the issuer to confirm the card has been activated.
     * This field will not be returned if the card is activated.
     */
    val activationSeed: ByteArray?,

    /**
     * Returned only if [SigningMethod.SignPos] enabling POS transactions is supported by card.
     */
    val paymentFlowVersion: ByteArray?,

    /**
     * This value can be initialized by terminal and will be increased by COS on execution of every [SignCommand].
     * For example, this field can store blockchain “nonce” for quick one-touch transaction on POS terminals.
     * Returned only if [SigningMethod.SignPos]  enabling POS transactions is supported by card.
     */
    val userCounter: Int?,

    /**
     * This value can be initialized by App (with PIN2 confirmation) and will be increased by COS
     * with the execution of each [SignCommand]. For example, this field can store blockchain “nonce”
     * for a quick one-touch transaction on POS terminals. Returned only if [SigningMethod.SignPos].
     */
    val userProtectedCounter: Int?,

    /**
     * When this value is true, it means that the application is linked to the card,
     * and COS will not enforce security delay if [SignCommand] will be called
     * with [TlvTag.TerminalTransactionSignature] parameter containing a correct signature of raw data
     * to be signed made with [TlvTag.TerminalPublicKey].
     */
    val terminalIsLinked: Boolean,

    /**
     * Detailed information about card contents. Format is defined by the card issuer.
     * Cards complaint with Tangem Wallet application should have TLV format.
     */
    val cardData: CardData?,

    var isPin1Default: Boolean? = null,

    var isPin2Default: Boolean? = null

) : CommandResponse

/**
 * Detailed information about card contents.
 */
class CardData(

    /**
     * Tangem internal manufacturing batch ID.
     */
    val batchId: String?,

    /**
     * Timestamp of manufacturing.
     */
    val manufactureDateTime: Date?,

    /**
     * Name of the issuer.
     */
    val issuerName: String?,

    /**
     * Name of the blockchain.
     */
    val blockchainName: String?,

    /**
     * Signature of CardId with manufacturer’s private key.
     */
    val manufacturerSignature: ByteArray?,

    /**
     * Mask of products enabled on card.
     */
    val productMask: ProductMask?,

    /**
     * Name of the token.
     */
    val tokenSymbol: String?,

    /**
     * Smart contract address.
     */
    val tokenContractAddress: String?,

    /**
     * Number of decimals in token value.
     */
    val tokenDecimal: Int?
)

/**
 * Status of the card and its wallet.
 */
enum class CardStatus(val code: Int) {
    NotPersonalized(0),
    Empty(1),
    Loaded(2),
    Purged(3);

    companion object {
        private val values = values()
        fun byCode(code: Int): CardStatus? = values.find { it.code == code }
    }
}